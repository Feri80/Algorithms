// compute center of circle given three points
PT ComputeCircleCenter (PT a, PT b, PT c){
  b=(a+b)/2;
  c=(a+c)/2;
  return ComputeLineIntersection (b,b+RotateCW90(a-b),
          c,c+RotateCW90(a-c));
}
// point generated by altitudes ( assuming it is triangle )
PT ComputeHcenter( PT p1, PT p2, PT p3 ) {
  PT a1 = ProjectPointLine( p2, p3, p1 );
  PT a2 = ProjectPointLine( p1, p3, p2 );
  return ComputeLineIntersection( p1, a1, p2, a2 );
}
// point generated by circumscribed circle ( assuming tri )
PT ComputeCenter( PT p1, PT p2, PT p3 ) {
  PT a1 = (p2+p3)*0.5;
  PT a2 = (p1+p3)*0.5;
  PT b1( a1.x - (p3.y-p2.y), a1.y + (p3.x-p2.x) );
  PT b2( a2.x - (p3.y-p1.y), a2.y + (p3.x-p1.x) ) ;
  return ComputeLineIntersection( a1, b1, a2, b2 );
}
PT ComputeCentroid (vector<PT> v){
  double cx = 0, cy = 0;
  double scale = 6.0 * SignedArea (v);
  for (int i = 0; i < v.size(); i++){
    int j = (i+1) % v.size();
    cx += (v[i].x+v[j].x)*(v[i].x*v[j].y-v[j].x*v[i].y);
    cy += (v[i].y+v[j].y)*(v[i].x*v[j].y-v[j].x*v[i].y);
  }
  PT res; res.x = cx/scale; res.y = cy/scale;
  return res;
}
// angle bisection ( assuming tri )
PT ComputebBcenter( PT p1, PT p2, PT p3 ) {
  double s1, s2, s3;
  s1 = dist( p2, p3 );
  s2 = dist( p1, p3 );
  s3 = dist( p1, p2 );
  double rt = s2/(s2+s3);
  PT a1 = p2*rt+p3*(1.0-rt);
  rt = s1/(s1+s3);
  PT a2 = p1*rt+p3*(1.0-rt);
  return ComputeLineIntersection( a1,p1, a2,p2 );
}